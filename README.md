# stateviz

Приложение для визуализации и отладки конечного автомата.

Автомат задаётся программой на собственном языке statelang, по которой приложение строит дерево состояний. При отсутствии ошибок компиляции программу можно запустить, чтобы пошагово отследить изменение значений.

## Список технологий

 * Компилятор языка написан на Java, коммуникация с фронтендом осуществляется с помощью Spring
 * Фронтенд реализован на [Svelte](https://svelte.dev/)
   * [Monaco Editor](https://microsoft.github.io/monaco-editor/) для редактора кода
   * [vis.js](https://visjs.org/) для визуализации дерева автомата

## Справка по языку statelang

Для примера рассмотрим программу, которая увеличивает счётчик, пока не достигнет заданного значения.

У такого автомата будет два состояния: `COUNTING` и `STOPPED`. Они определяются с помощью блока `state` на верхнем уровне программы:

```
state {
  COUNTING, # первое состояние считается начальным
  STOPPED
}
```

Далее нам нужно объявить переменную счётчика и константу остановки:

```
let count := 0;
const stop := 10;
```

Замечания:
 * язык строго типизирован, но указывать типы вручную не нужно
 * нет разграничения на int и float, все числа дробные
 * оператор присваивания - `:=`, а сравнения - `=`

Затем объявим действия автомата в состоянии `COUNTING`:

```
when COUNTING {
  assert count < stop;   # проверяем корректность состояния
  count := count + 1;    # увеличиваем счётчик
  if count = stop {
    state := STOPPED;    # переходим в STOPPED, если достигнуто значение stop
  }
}
```

Замечания:
 * `assert` завершит программу с ошибкой, если его условие не равно истине
 * присваивание в `state` - переход в другое состояние
   * программа выходит из блока при переходе по аналогии с `return` в обычных языках
   * код после перехода будет помечен как недостижимый
